
## 面向对象设计模式的目的
* 提高复用
* 隔离变化
* 高内聚, 低耦合

## 面向对象设计原则
* 依赖倒置原则(DIP)
    * 高层模块(稳定)不应该依赖于底层模块(变化), 两者都应该依赖于抽象(稳定)
    * 抽象(稳定)不应该依赖于实现细节(变化), 实现细节(变化)应该依赖抽象(稳定)
    * 面向接口编程(稳定), 不要面向业务编程(变化)
* 开放封闭原则(OCP)
    * 对扩展开放, 对修改关闭
    * 扩展新功能尽量不影响旧功能
* 单一职责原则(SRP)
    * 一个类只负责一项职责
* 里氏替换原则(LSP)
    * 子类应该完全替换基类(IS-A)
* 接口隔离原则(ISP)
    * 接口应该尽可能小, 不要有没用的内容
* 迪米特法则: 只依赖直接的类
* 组合复用原则: 多用组合, 少用继承, 继承的耦合性更强

## 可复用面向对象的设计模式: 隔离变化

### 创建型
* 单例模式 ------ 已处理
* 工厂方法
    * 工厂类多个, 业务类多个, 一个工厂类产生一个业务类
    * 实现复杂, 不易出错, 对修改关闭, 对扩展开放
* 简单工厂模式
    * 工厂类一个, 业务类多个, 一个工厂类产生一个业务类
    * 实现简单
* 抽象工厂模式
    * 工厂类多个, 业务类多个, 一个工厂类产生一批业务类
    * 实现简单
* 建造者模式
    * 构造函数参数过多或可选时使用, 便于可以链式构造
    * 将类的构造从类中剥离出来
* 原型模式
    * 需要考虑对象的中间状态
    * 无法知道类的具体类型的情况
    * 可以考虑使用拷贝构造函数

### 对象型
* 适配器模式 ---- 为方便使用或兼容再封一层, 比如 C++ 的 stack
* 装饰者模式 ----
* 代理模式 ------
* 外观模式 ------
* 桥接模式 ------ m n => m+n
* 组合模式 ------ 组合多个复杂的对象
* 享元模式 ------

### 行为型
* 策略模式(strategy)
    * 相同部分提取到基类, 不同的部分在子类实现
    * 替换 ifelse 分支
    * 完全不变的 ifelse 部分可以保留
* 模板方法模式:
    * 基类定义好模板(稳定的)
    * 模板内使用虚方法(不稳定)
    * 子类实现虚方法(不稳定)
* 观察者模式
* 迭代器模式
* 责任链模式
* 命令模式
* 备忘录模式
* 状态模式
* 访问者模式
* 中介者模式
* 解释器模式

