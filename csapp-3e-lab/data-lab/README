***********************
 csapp-3e-lab-data-lab
***********************

本实验主要用于熟悉整数和浮点数的位的表示

实验官网：http://csapp.cs.cmu.edu/3e/labs.html

********************************************
问题一：使用位操作 非 和 且 实现位操作 异或
********************************************
思路：

对于 x，y 中的每一位，都有以下四种情况：
1. x 中为 0，y 中为 0
2. x 中为 0，y 中为 1
3. x 中为 1，y 中为 0
4. x 中为 1，y 中为 1

我们需要的只有情况 2 和 情况 3，但是由于我们不能使用 或 操作，
所以无法直接找到情况 2 和 情况 3，也不能直接将情况 2 和 情况 3 相 或，
因此，我们这里使用 非 操作，利用情况 1 和 情况 4，
找到同时包含情况 1 2 3 的情况 和 同时包含情况 2 3 4 的情况，
然后取 且 操作

代码：

  int bitXor(int x, int y) {
    // 情况 1
    int a = (~x) & (~y);
    // 情况 2 3 4
    int b = ~a;
    // 情况 4
    int c = x & y;
    // 情况 1 2 3
    int d = ~c;
    return b & d;
  }

********************************************
问题二：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    求得整数的最小值
********************************************
思路：

由于，题目假设整数为 32 位，
而，补码表示的最小值为：符号位为 1，其它位为 0，
所以直接移位即可

代码：

  int tmin(void) {
    return 0x1 << 31;
  }

**********************************
问题三：
    使用
        位操作 非、且、或、异或，
        逻辑操作 非，
        加法运算符
    判断 x 是否是整数的最大值
**********************************
思路：

就 补码 而言，满足 ~x + 1 == x 的情况只有两种，即 0x0000 0000 和 0x8000 0000，
而，整数的最大值为 0x7FFF FFFF，
所以，如果 x == 0x7FFF FFFF，x + 1 == 0x8000 0000，
      如果 x == 0xFFFF FFFF，x + 1 == 0x0000 0000，
所以，我们只需要判断 ((~x) + 1) ^ x 为 0，
然后，排除掉 x 为 0 的情况

注意：

最好不要使用可能导致溢出的代码，可能会有可移植性的问题

代码：

  int isTmax(int x) {
    int y = x + 1;
    return (!((~y + 1) ^ y)) & (!!y);
  }

*******************************************
问题四：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 x 的奇数位是否都为 1，
    从右往左数，[0, 31]
*******************************************
思路：

只要 x & 0xAAAA AAAA == 0xAAAA AAAA 即可，
但是，题目要求不能使用大于 0xFF 的常量，
所以，我们通过 将 0xAA 移位来获取 0xAAAA AAAA

代码：
  int allOddBits(int x) {
    // a == 0xAAAA
    int a = (0xAA << 8) + 0xAA;
    // a == 0xAAAA AAAA
    a = (a << 16) + a;
    return !((a & x) ^ a);
  }

*******************************************
问题五：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    求 x 相反数
*******************************************
思路：

对于 补码 而言，x 的相反数为 ~x + 1

代码：

  int negate(int x) {
    return ~x + 1;
  }

************************************************
问题六：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 x 是否属于 [0x30, 0x39] 即 ['0', '9']
************************************************
思路：

给定数字 a，我们可以找一个临界点，
使得 当 x <  0x30 时，a + x <  0
     当 x >= 0x30 时，a + x >= 0
给定数字 b，我们可以找一个临界点，
使得 当 x <= 0x39 时，b + x <  0
使得 当 x >  0x39 时，b + x >= 0

详情见代码注释

注意：尽量不要使用位右移

代码：

  int isAsciiDigit(int x) {
    int sign;
    int a;
    int b;

    // 符号位置为 1，其它位为 0
    sign = 0x1 << 31;

    // a == -0x30 即：0x30 + a == 0
    a = ~0x30 + 1;

    // 获取 x + a 的符号位，其它位置为 0
    a = sign & (a + x);

    // 对 a 的符号位取反，其它位依然是 0
    a = sign & (~a);

    // b == ~0x39 == ~0x39 + 1 - 1 == -0x39 - 1 == -0x3a
    // 即：0x39 + b == -1
    // 即：0x3a + b ==  0
    b = ~0x39;

    // 获取 x + b 的符号位，其它位置为 0
    b = sign & (b + x);

    // 如果 x 属于 [0x30, 0x39]
    // a == 0x8000 0000
    // b == 0x8000 0000
    return !!(a & b);
  }

************************************************
问题七：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    实现条件运算符
************************************************
思路：

0x0000 0000 和 x 进行 位操作 与 结果为 0x0000 0000
0x0000 0000 和 x 进行 位操作 或 结果为 x
0xFFFF FFFF 和 x 进行 位操作 与 结果为 x

如果 x == 0，则 !!x == 0
如果 x != 0，则 !!x == 1

如果 x == 0，则 ~x + 1 ==  0 即 x == 0x0000 0000
如果 x == 1，则 ~x + 1 == -1 即 x == 0xFFFF FFFF

所以，先将 x 转为 0 或 1，然后转为 0x0000 0000 或 0xFFFF FFFF，
最后，如果 x == 0，
           (x & Y) | (~x & z) == 0 | z == z
      如果 x != 0，
           (x & Y) | (~x & z) == y | 0 == y

  int conditional(int x, int y, int z) {
    // x == 0 或 1
    x = !!x;
    // x == 0x0000 0000 或 0xFFFF FFFF
    x = ~x + 1;
    return (x & y) | (~x & z);
  }

************************************************
问题八：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 小于等于
************************************************
思路：

不能直接相减，因为，异号相减可能会溢出，
所以，我们总共有分四种情况：
1. x >= 0, y >= 0
2. x >= 0, y <  0
3. x <  0, y >= 0
4. x <  0, y <  0

判断是否同号，用符号位的异或，
求 x - y 用 x + ~y + 1

其它思路和实现条件运算符很像

详情见代码注释

代码：

  int isLessOrEqual(int x, int y) {
    int sign;
    int a;
    int b;
    int c;
    int d;

    // 符号位置为 1，其它位为 0
    sign = 0x1 << 31;

    // 如果 a，b 异号，a == 0x8000 0000，否则，a == 0x0000 0000
    a = (sign & x) ^ (sign & y);

    // 如果 a，b 异号，a == 1，否则，a == 0
    a = !!a;

    // 如果 a，b 异号，a == 0xFFFF FFFF，否则，a == 0x0000 0000
    a = ~a + 1;

    // b = x - y
    b = x + ~y + 1;

    // 如果 x，y 异号 且 x <  0，c == 1，否则，c == 0
    c = !!(a & (x & sign));

    // 如果 x，y 同号 且 x <= y，c == 1，否则，c == 0
    d = !!((~a) & ((b & sign) | (!b)));

    return c | d;
  }

************************************************
问题九：
    使用
        位操作 非、且、或、异或、左移右移，
        加法运算符
    实现逻辑 非
************************************************
思路：

分三种情况：
1. 0x0000 0000 的补码是其本身，符号位是 0
2. 0x8000 0000 的补码是其本身，符号位是 1
3. x 与 -x 对应的符号位为 01 或 10

详情见代码注释

代码：

  int logicalNeg(int x) {
    int a;
    int b;

    // 如果 x 与 -x 的符号位不同，a 的最低位为 1, 否则 a 的最低位为 0
    a = (x ^ (~x + 1)) >> 31;

    // 如果 x 的最高位为 1，b 的最低位为 1，否则，b 的最低位为 0
    b = x >> 31;

    return ~(a | b) & 0x1;
  }

************************************************
问题十：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断至少需要多少位，才能存储 x
************************************************
思路：

如果高位有 1，则，低位是必须的，
比如，如果，[16, 32) 位存在 1，则 [0, 16) 未是必须的，
因此，每次可以砍掉一半的情况

如果，x < 0，必须处理掉前面连续的 1，通过取反来获得

最后记得加上符号位

详情见代码注释

代码：

  int howManyBits(int x) {
    int a;
    int b;
    int ret;

    // 如果，x < 0，a == 1，否则，a == 0
    a = (x >> 31) & 0x1;

    // 如果，a == 1，a == 0xFFFF FFFF，否则，a == 0x0000 0000
    a = ~a + 1;

    // 如果 x >= 0, 则不变，
    // 如果 x <  0，按位取反，前面连续的 1 都变为 0
    x = (a & ~x) | (~a & x);

    // 位从右往左数，从 0 开始

    // 如果 x 的 [16, 32) 位存在 1，b == 16，否则，b == 0
    b = !!(x >> 16) << 4;
    // 如果 x 的 [16, 32) 位存在 1
    //    则 [0, 16) 位是必须的，只要判断 [16, 32) 位即可，
    //    将 x 右移 16 位
    ret = b;
    x = x >> b;

    // 接下来判断 [8, 16) 位
    // 如果 x 的 [8, 16) 位存在 1，b == 8，否则，b == 0
    b = !!(x >> 8) << 3;
    // 如果 x 的 [8, 16) 位存在 1
    //    则 [0, 8) 位是必须的，只要判断 [8, 16) 位即可，
    //    将 x 右移 8 位
    ret += b;
    x = x >> b;

    // 接下来判断 [4, 8) 位
    // 如果 x 的 [4, 8) 位存在 1，b == 4，否则，b == 0
    b = !!(x >> 4) << 2;
    // 如果 x 的 [4, 8) 位存在 1
    //    则 [0, 4) 位是必须的，只要判断 [4, 8) 位即可，
    //    将 x 右移 4 位
    ret += b;
    x = x >> b;

    // 接下来判断 [2, 4) 位
    // 如果 x 的 [2, 4) 位存在 1，b == 2，否则，b == 0
    b = !!(x >> 2) << 1;
    // 如果 x 的 [4, 8) 位存在 1
    //    则 [0, 2) 位是必须的，只要判断 [2, 4) 位即可，
    //    将 x 右移 2 位
    ret += b;
    x = x >> b;

    // 接下来判断 [1, 2) 位
    // 如果 x 的 [1, 2) 位存在 1，b == 1，否则，b == 0
    b = !!(x >> 1) << 0;
    // 如果 x 的 [1, 2) 位存在 1
    //    则 [0, 1) 位是必须的，只要判断 [1, 2) 位即可，
    //    将 x 右移 1 位
    ret += b;
    x = x >> b;

    // 接下来判断 [0, 1) 位
    ret += x;

    return ret + 1; // 加上符号位
  }

************************************************
问题十一：
    实现浮点数乘以 2
************************************************
思路：

浮点数总共分三种情况：
1. 阶码部分不为 0x0000 0000，表示  规格化的值
2. 阶码部分  为 0x0000 0000，表示非规格化的值
3. 阶码部分  为 0x1111 1111，尾码部分  为 0，表示无穷大 或 无穷小
3. 阶码部分  为 0x1111 1111，尾码部分不为 0，表示 NaN

情况一，直接将 阶码加 1，如果加后的结果为 255，
        则，返回 无穷大 或 无穷小，否则，返回 加 1 后的结果

情况二，直接将 尾码 左移一位 即可

情况三，直接返回 uf

情况四，直接返回 uf

详情见代码注释

代码：

  unsigned floatScale2(unsigned uf) {
    int sign;
    int exp;

    // 获取符号位
    sign = uf & (1 << 31);

    // 阶码部分
    exp = (uf & 0x7f800000) >> 23;

    // 阶码为 0，表示非规格化的值，即，尾码不包含前置的 1
    // 尾码直接左移一位表示乘以 2，然后，加上 符号位即可
    if (exp == 0)
      return uf << 1 | sign;

    // 阶码为 255，表示 无穷小 或 无群大  或 NaN
    if (exp == 255)
      return uf;

    exp++;
    if (exp == 255)
      return 0x7f800000 | sign; // 无穷小 或 无穷大
    return (exp << 23) | (uf & 0x807fffff);
  }

************************************************
问题十二：
    将浮点数转化为整数
************************************************
思路：

int 只有 32 位，所以，
如果 阶数 大于 31，肯定溢出，返回 0x8000 0000
如果阶数 小于 0，则是小数，返回 0

获取尾数，然后，根据阶数，左移 或 右移
如果移位后的数小于 0，直接溢出，返回 0x8000 0000
否则，根据 uf 的最高位变更符号位

详情见代码注释

代码：

  int floatFloat2Int(unsigned uf) {
    int exp;
    int frac;

    // 获取 阶码
    exp = ((uf & 0x7f800000) >> 23) - 127;

    // int 的最大值为 0x7FFFF FFFF
    // 即：2 的 31 次 - 1
    // int 的最小值为 0x80000 0000
    // 即：- 2 的 31 次
    // 如果 阶数 大于 31 肯定溢出
    if (exp > 31)
      return 0x80000000;

    // 如果 阶数 小于 0 ，结果是小数
    if (exp < 0)
      return 0;

    // 活得尾数，并加上省略前置的 1
    frac = (uf & 0x007fffff) | 0x00800000;

    // 阶数大于 23，需要将尾数左移
    if (exp > 23)
      frac <<= (exp - 23);
    // 阶数小于 23，需要将尾数右移
    else
      frac >>= (23 - exp);

    // frac uf 的最到位都为 0
    if (frac >= 0 && uf < 0x80000000)
      return frac;
    // frac 的最到位为 0，uf 最高位为 1
    else if (frac >= 0 && uf >= 0x80000000)
      return -frac;
    else
      // frac 的最高位为 1，frac 不足以存储 uf，溢出
      return 0x80000000;
  }

************************************************
问题十三：
    求 2.0 的 x 次
************************************************
思路：

2.0 的 x 次 等于 1.0 乘以 2 的 x 次，
所以，只要处理阶码即可，其它部分为 0

如果溢出，返回 0x7F80 0000

详情见代码注释

代码：

  unsigned floatPower2(int x) {
    int exp = x + 127;

    // 阶码必须大于等于 0
    // 如果 exp == 0，尾码没有前置的 1，所以结果也为 0
    if (exp <= 0)
      return 0;

    // 阶码必须小于等于 255
    // 如果 exp == 255，表示 无穷大 无穷小 或 NaN，所以结果也为 0xff << 23
    // 即：符号位为 0，阶码的位都为 1，尾码的位都为 0
    if (exp >= 255)
      return 0xff << 23;

    // 符号位为 0，尾码为 0
    return exp << 23;
  }

总结：
  
1. 尽量不要使用位操作，太麻烦了
2. 尽量不要产生溢出，因为溢出的结果可能不唯一
3. 尽量不要使用右移，因为得区分 逻辑右移 还是 算数右移




