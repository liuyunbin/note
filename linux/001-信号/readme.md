
# 计算机操作系统-信号
## 信号产生
* 终端相关(由 0 号进程发送)
* 硬件异常
* 资源就绪或资源受限(由 0 号进程发送)
* 自身或其他进程发送

## 信号-阻塞
### 说明
* `SIGKILL` 和 `SIGSTOP` 无法被阻塞
* `SIGCONT` 可以被阻塞, 但好像没啥用

### 测试
1. 阻塞所有信号
2. 此时, 可以看到除 SIGKILL 和 SIGSTOP 外, 其他信号都被阻塞了
3. 向自身发送除了 SIGKILL 和 SIGSTOP 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
4. 此时, 可以看到除 SIGKILL SIGSTOP 和 SIGCONT 外, 其他信号都处于待决状态

测试文件: [01.cc](./01.cc)

## 信号-优先级
### 说明
* 有多个信号处于未决状态(信号发送后, 处理前)时, 进程处理的顺序

### 测试
1. 为所有信号注册信号处理函数, 并设置信号处理过程中阻塞其他信号
2. 阻塞所有信号
3. 向自身发送除了 SIGKILL 和 SIGSTOP 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
4. 解阻塞所有信号
5. 此时, 可以看到信号捕获的顺序
    * 04-SIGILL
    * 05-SIGTRAP
    * 07-SIGBUS
    * 08-SIGFPE
    * 11-SIGSEGV
    * 31-SIGSYS
    * 其他信号按数字的从小到大顺序处理

测试文件: [02.cc](./02.cc)

## 信号-不可靠
### 相同的信号处于待决状态时, 只记录一个, 其他信号会丢失
1. 设置 SIGUSR1 的信号处理函数
2. 阻塞信号 SIGUSR1
3. 向自身发送信号 SIGUSR1 五次
4. 解除信号 SIGUSR1 阻塞
5. 可以看到 SIGUSR1 只捕获到一次

测试文件: [03.cc](./03.cc)

### 信号处理后, 信号处理函数可能会被重置
1. 设置 SIGUSR1 的信号处理函数
2. 设置信号触发后被重置
3. 发送信号 SIGUSR1 第 1 次, 正常捕获
4. 发送信号 SIGUSR1 第 2 次, 进程直接退出

测试文件: [04.cc](./04.cc)

## 信号-信号处理
### 第一种: 忽略信号
### 第二种: 默认处理(忽略, 退出, 退出产生core, 暂停, 继续)
### 第三种: 捕获信号, 信号处理过程中, 相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃
1. 设置信号 SIGUSR1 处理函数, 处理函数休眠 2 秒，便于观察
2. 产生子进程, 子进程空循环
3. 父进程向子进程发送信号 SIGUSR1 第一次
4. 此时, 观察到子进程正在执行信号处理函数
5. 父进程向子进程发送信号 SIGUSR1 第二次
6. 父进程向子进程发送信号 SIGUSR1 第三次
7. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
8. 然后, 处理第二次信号
9. 不会处理第三次信号, 这个信号丢失了

测试文件: [05.cc](./05.cc)

### 第四种: 捕获信号, 信号处理过程中, 不同的信号来了会被直接执行, 执行完之后, 再继续执行之前的函数
1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒，便于观察
2. 产生子进程
3. 子进程空循环
4. 父进程向子进程发送信号 SIGUSR1
5. 此时, 观察到子进程正在执行信号处理函数
6. 父进程向子进程发送信号 SIGUSR2
7. 此时, 观察到子进程直接处理信号 SIGUSR2，直到完成
8. 然后, 继续处理 SIGUSR1, 直到完成

测试文件: [06.cc](./06.cc)

### 第五种: 使用 sigaction() 可以选择阻塞的信号集
1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒, 便于观察，并设置信号处理过程中阻塞 SIGUSR2
2. 产生子进程
3. 子进程空循环
4. 父进程向子进程发送信号 SIGUSR1
5. 此时, 观察到子进程正在执行信号处理函数
6. 父进程向子进程发送信号 SIGUSR2
7. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
8. 然后, 开始处理 SIGUSR2, 直到完成

测试文件: [07.cc](./07.cc)

## 慢系统调用
被信号中断时, 需要重新启动

## 不可重入函数
需要阻塞某些信号

### 常见信号
|  信号      |处理|说明                                               |
|------------|----|---------------------------------------------------|
| 1-SIGHUP   |term|发送给会话首进程(终端断开)                         |
|            |    |发送给其所有作业(会话首进程退出)                   |
|            |    |发送给守护进程(重新读取其配置文件)                 |
| 2-SIGINT   |term|键盘中断, 由 ctrl+c 产生                           |
| 3-SIGQUIT  |core|键盘退出, 由 ctrl+\ 产生                           |
| 4-SIGILL   |core|非法的硬件指令                                     |
| 5-SIGTRAP  |core|硬件故障                                           |
| 6-SIGABRT  |core|异常终止, 由 abort() 产生                          |
|            |    |  默认处理, 进程退出                       -- 08.cc|
|            |    |  忽略信号, 进程退出                       -- 09.cc|
|            |    |  捕获信号, 并从信号处理函数返回, 进程退出 -- 10.cc|
|            |    |  捕获信号, 不从信号处理函数返回, 进程继续 -- 11.cc|
| 7-SIGBUS   |core|硬件故障, 内存故障                                 |
| 8-SIGFPE   |core|算术异常, 比如除以0                                |
|            |    |  忽略信号, 进程退出                               |
|            |    |  默认处理, 进程退出                               |
|            |    |  捕获信号, 并从信号处理函数返回, 将继续触发此信号 -- 12.cc |
|            |    |  捕获信号, 不从信号处理函数返回, 进程继续运行     |
| 9-SIGKILL  |term|退出, 不能被阻塞, 捕获, 忽略                       |
|10-SIGUSR1  |term|用户自定义信号                                     |
|11-SIGSEGV  |core|无效内存引用, 比如访问未初始化的指针               |
|12-SIGUSR2  |term|用户自定义信号                                     |
|13-SIGPIPE  |term|写文件描述符时, 对方已退出, 比如 socket, 管道      |
|14-SIGALRM  |term|定时器超时, 由 alarm() 或 setitimer() 产生         |
|15-SIGTERM  |term|退出信号, kill 默认信号                            |
|16-SIGSTKFLT|term|栈错误, 未使用                                     |
|17-SIGCHLD  |ign |子进程暂停或继续或退出时, 会向父进程发送此信号     |
|            |    |  父进程设置默认处理后, 会忽略此信号               |
|            |    |  父进程设置忽略信号后, 会忽略此信号                                   |
|            |    |  父进程设置捕获信号后, 会调用信号处理函数处理                -- 13.cc |
|            |    |  父进程使用 sigaction 设置 `SA_NOCLDSTOP` 后, 不再接收此信号 -- 14.cc |
|            |    |子进程退出时, 会向父进程发送此信号                                     |
|            |    |  父进程设置 sigaction 的 `SA_NOCLDWAIT` 后, 不会产生僵尸进程          |
|            |    |  父进程设置默认处理,   会产生僵尸进程                                 |
|            |    |  父进程设置忽略信号, 不会产生僵尸进程                                 |
|            |    |  父进程设置捕获信号, 并调用 waitpid() 类函数一次, 可能会产生僵尸进程  |
|            |    |  父进程设置捕获信号, 并调用 waitpid() 类函数循环,   不会产生僵尸进程  |
|18-SIGCONT  |cont|继续, 待决的暂停信号将被丢弃, 此信号阻塞没用       |
|19-SIGSTOP  |stop|暂停, 不能被阻塞 捕获 忽略, 待决的继续信号将被丢弃 |
|20-SIGTSTP  |stop|暂停, 由 ctrl+z 产生, 待决的继续信号将被丢弃       |
|21-SIGTTIN  |stop|后台进程读取终端输入, 待决的继续信号将被丢弃       |
|22-SIGTTOU  |stop|后台进程输出到终端, 待决的继续信号将被丢弃         |
|23-SIGURG   |ign |带外数据就绪                                       |
|24-SIGXCPU  |core|cpu 使用超出限制                                   |
|25-SIGXFSZ  |core|文件大小超出限制                                   |
|26-SIGVTALRM|term|setitimer() 产生的虚拟的超时信号                   |
|27-SIGPROF  |term|setitimer() 产生的虚拟的超时信号                   |
|28-SIGWINCH |ign |终端大小发生变化                                   |
|29-SIGIO    |term|异步IO就绪                                         |
|30-SIGPWR   |term|电池问题                                           |
|31-SIGSYS   |core|非法的系统调用                                     |

### 相关函数
|函数           |说明                                                       |
|---------------|-----------------------------------------------------------|
| abort()       | 解锁信号 SIGABRT, 然后向自身发送 SIGABRT                  |
| alarm()       | 指定时间后, 收到信号 SIGALRM                              |
|               | 如果以前未设置且此次参数不为0                             |
|               |     设置为新值, 返回 0                                    |
|               | 如果以前已设置且此次参数不为0                             |
|               |     设置为新值, 返回上一次的剩余的时间                    |
|               | 如果以前已设置且此次参数为0                               |
|               |     取消上一次的设置的值, 并返回上一次剩余的时间          |
| exec()        | 设置捕获的信号处理函数恢复为默认处理                      |
| fork()        | 信号处理函数也被复制, 信号处理不变                        |
| kill()        | 发送信号, 向某一进程 或 进程组                            |
|               | root 可以向任何进程发送                                   |
|               | 其他用户需要与目标进程的实际或有效用户相同                |
| pause()       | 休眠, 直到不被忽略的信号发生                              |
| raise()       | 向自己发送信号                                            |
| sleep()       | 休眠n秒, 或者一个未被忽略的信号到达                       |
| signal()      | 设置信号处理函数                                          |
|               | 信号处理函数不会被重置                                    |
|               | 被中断系统调用会自动重启                                  |
|               | 信号处理时, 自身会被阻塞, 其他信号不会                    |
| sigaction()   | 设置信号处理函数                                          |
|               | 可以选择是否自动重启被中断的系统调用                      |
|               | 可以选择第一次调用以后, 信号处理函数是否恢复成默认处理    |
|               | 可以选择信号处理过程中, 是否阻塞自身或指定信号集          |
|               | 可以指明对子进程状态变化的处理                            |
|               | 可以获取到发送信号一端的一些信息                          |
| sigemptyset() | 将信号集置空                                              |
| sigfillset()  | 填充所有信号                                              |
| sigaddset()   | 添加信号到信号集                                          |
| sigdelset()   | 从信号集删除信号                                          |
| sigismember() | 判断信号是否处于信号集                                    |
| sigprocmask() | 阻塞 或 解阻塞 或 查看信号                                |
| sigpending()  | 查看处于待决状态的信号                                    |
| sigsetjmp()   | 跨函数跳转, 自动恢复信号                                  |
| siglongjmp()  | 跨函数跳转, 自动恢复信号                                  |
| sigsuspend()  | 解阻塞一些信号, 然后等待, 原子操作                        |
|               |                                                           |
| system()      | 1. 阻塞 SIGCHLD, 否则无法知道是不是自己创建的子进程退出了 |
|               | 2. 忽略 SIGINT 和 SIGQUIT                                 |
|               | 3. 子进程恢复 SIGINT 和 SIGQUIT 的处理                    |
|               | 4. 父进程 waitpid() 子程序                                |
|               | 5. 父进程恢复 SIGCHLD SIGINT 和 SIGQUIT 的处理            |

## 信号-测试: 捕获所有信号, 用于测试
测试文件: [15.cc](./15.cc)

## 相关命令
```
kill         pid # 通过进程ID发送信号给进程或进程组
kill -signal pid # 指定信号，默认值为 SIGTERM
kill -l          # 列出所有信号

killall             # 通过进程名称发送信号给进程或进程组, 进程名称精确匹配
killall -l          # 列出所有信号
killall -o 2m a.out # 发给 2 分钟前启动的 a.out
killall -y 2m a.out # 发给 2 分钟内启动的 a.out
killall -w    a.out # 等待进程结束

pkill         ... # 杀死进程, 扩展的正则表达式，参数和 pgrep 类似 -- 常用
pkill -signal ... # 指定信号，默认值为 SIGTERM
```

