
## TCP
* 面向连接的, 可靠的, 字节流协议 -- 可靠指的是序列号
* 估算往返时间: RTT
* 不一定 100% 可靠
* 流量控制 -- 避免网络阻塞 -- 通告窗口
* 全双工

## 三次握手
1. 客户端将随机的序列号发送给服务端(SYN)(CLOSED -> SYN-SENT)
2. 服务端收到数据后, 知道了客户端的序列号
   * 服务端将自己随机的序列号以及客户端序列号加一返回给客户端(SYN ACK)(LISTEN -> SYN-RCVD)
3. 客户端收到数据后, 认为连接已经建立成功了
   * 客户端将服务端的序列号加一发送给服务端(ACK)(SYN-SENT -> ESTABLISHED)
   * 此时客户端就可以发送数据了
4. 服务端收到数据后, 认为连接已经建立成功了, 可以发送数据了(SYN-RCVD -> ESTABLISHED)

## 四次挥手(服务端也可以先发起)
1. 客户端发送 FIN(ESTABLISHED -> FIN-WAIT-1)
2. 服务端收到 FIN(ESTABLISHED -> CLOSE-WAIT
    * 服务端向客户端发送确认
    * 客户端收到确认(FIN-WAIT-1 -> FIN-WAIT-2)
    * 此时, 客户端不能再向服务端发送数据, 但服务端可以向客户端发送数据
3. 服务端发送 FIN(CLOSE-WAIT -> LAST-ACK)
4. 客户端收到 FIN(FIN-WAIT-2 -> TIME-WAIT)
    * 向服务端发送确认
    * 等待 2MSL, 客户端(TIME-WAIT -> CLOSED)
    * (为了处理服务端可能收不到确认的情况, 也为了让游离在外的包尽可能消亡)
    * 服务端收到确认(LAST-ACK -> CLOSED)

## 为什么需要序列号(32位):
* 数据包需要被确认, 而包可能会被拆, 需要使用序列号来判断确认到哪个数据包了
* 数据包可能会丢失, 需要使用序列号来判断需要重发哪个数据包
* 数据包可能会重复, 需要使用序列号来丢弃重复的数据包
* 数据包到达的时间, 顺序可能不同, 需要使用序列号排序

## 初始序列号为什么随机生成:
* 随机序列号很难猜测, 为了避免其他人冒充对方报文, 或 伪造reset报文, 影响正常的使用
* 为了避免旧数据影响新连接, 例如
    * 客户端连接服务端
    * 客户端向服务端发送一个数据包(由于网络问题, 数据包发了两次, 有游离包在网络中)
    * 客户端向服务端发送 reset, 立刻退出(没有经过正常的四次挥手)
    * 此时, 客户端使用相同的IP和端口号重新连服务端, 并成功
    * 此时, 游离的包到达服务端,
    * 如果初始话序列号相同, 此游离包  在服务端的接收窗口内, 会被误认为是新的数据包, 而返回确认
    * 如果初始话序列号不同, 此游离包不在服务端的接收窗口内, 会被丢弃(极大概率)

## 序列号回绕:
* 初始化序列号每4微妙增长一个, 即, 每秒增长 250000 个, 循环一次需要 4 个多小时
* 使用时间戳可以处理序列号回绕导致的历史包的问题

## 报文类型
*   SYN: 三次握手(需要确认, 可能会重传)
*   FIN: 四次挥手(需要确认, 可能会重传)
*  data: 数据报文(需要确认, 可能会重传)
* reset: 重置(不需要确认,   不会重传)(发送重置后, 内核会销毁掉所有的连接信息, 对方的确认没意义)
*   ACK: 确认(不需要确认,   不会重传)(如果确认的话就死循环了)(不包含数据)(下一个期望的序列号)
*   ACK: 确认(  需要确认, 可能会重传)(如果确认的话就死循环了)(  包含数据)(下一个期望的序列号)
* 所有有数据的报文都需要ack, 也可能会重传
* SYN 和 FIN 为什么占一个序列号: 为了处理可能的重传

## reset 发送场景:
* 客户端连接服务端, 而服务端的此端口没有被监听, 会返回 rst
* 客户端连接服务端, 被防火墙拦截(不一定, 可能收到 ICMP 错误)
* 当接收缓冲区内还有数据, 但关闭了该 socket, 会向对方发送 rst
* 向已关闭的 socket 发送数据, 对方会返回 rst

## 为什么需要三次握手:
1. 一次握手:
    * 客户端发送连接, 即认为连接成功, 服务端收到连接, 即认为连接成功
    * 由于客户端无法知道服务端的序列号, 也就没有序列号这一说了,
    * TCP 的包不能拆分了(无法确认数据包的先后), 也就没有确认机制了(无法确认),
    * 直接相当于 UDP 了
2. 两次握手:
    * 客户端发送连接
    * 服务端收到连接, 并返回确认, 此时, 服务端认为连接成功了
    * 客户端收到确认, 认为连接成功了
    * 如果客户端的连接包丢失了, 由于无法收到确认包, 所以会重新发送连接包
    * 如果服务端的确认包丢失了, 服务端感知不到这种情况,
        * 由于客户端接收不到确认包, 所以客户端仍然会重新发送连接包
    * 旧的连接包会影响服务端的使用, 例如,
        * 客户端连接服务端(由于网络问题, 连接包发了两次, 有一个游离包在网络中)
        * 服务端返回确认
        * 客户端收到确认, 向服务端发送 reset, 立刻退出(没有经过正常的四次挥手)
        * 此时, 游离的包到达服务端, 服务端认为是新的连接, 向客户端发送确认
        * 客户端收到子虚乌有的确认直接丢弃了
        * (客户端可以考虑发送 reset 让服务端释放资源也成, 客户端不存在或不可达也还是有问题)
        * 服务端直到发送数据, 才能知道连接不成功(不发送的话, 一直浪费)
3. 三次握手:
    * 客户端发送连接
    * 服务端收到连接, 并返回确认
    * 客户端收到确认, 并返回确认, 认为连接成功了
    * 服务端收到确认, 认为连接成功了
    * 如果客户端的连接包丢失了, 由于无法收到确认包, 所以会重新发送
    * 如果服务端的确认包丢失了, 由于无法收到确认包, 所以会重新发送
    * 旧的连接包不会影响服务端的使用, 例如,
        * 客户端连接服务端(由于网络问题, 连接包发了两次, 有一个游离包在网络中)
        * 服务端返回确认
        * 客户端收到确认, 向服务端发送 reset, 立刻退出(没有经过正常的四次挥手)
        * 此时, 游离的包到达服务端, 服务端认为是新的连接, 向客户端发送确认
        * 客户端收到子虚乌有的确认直接丢弃了(客户端也可以考虑发送 reset)
        * 服务端没收到确认消息, 会多次发送, 最终放弃, 释放资源
4. 其实, 两次握手也能成功, 兼顾效率和可靠性, 选择三次握手(主要是网络出问题的情况)
    * 三次握手保证双方都知道对方是可收可发的(保证是可用的, 不一定是可靠的)
    * 也都知道了对方的初始化序列号

