
# 计算机组成原理-整数-浮点数-字符
## 本文主要讨论数据在内存以及文件中存储
* 基础知识(原码 反码 补码 移码 字节序)
* 无符号的整数的存储(内存以及二进制文件)
* 有符号的整数的存储(内存以及二进制文件)
* 浮点数的存储(内存以及二进制文件)
* 字符存储(内存 二进制文件 文本文件)
* 查看二进制(内存)
* 查看二进制(文件)

## 基础知识(原码 反码 补码 移码 字节序)

### 加减法的所有类型
* 正数+正数:
* 正数-正数:
* 正数+负数: 可以转化为 正数-正数
* 正数-负数: 可以转化为 正数+正数
* 负数+正数: 可以转化为 正数-正数
* 负数+负数: 可以转化为 正数+正数, 然后把正数变成负数
* 负数-正数: 可以转化为 正数+正数, 然后把正数变成负数
* 负数-负数: 可以转化为 正数-负数
* 正数: 可以转化为    0+正数
* 负数: 可以转化为    0-正数

所以我们考虑加减法只要处理 正数+正数 和 正数-正数 的情况就可以了

### 原码
* 正数: 符号位为 0
* 负数: 符号位为 1
* +0: 0000
* -0: 1000
* 最大: 0111(+7)
* 最小: 1111(-7)
* 比较大小:
    * 先比较符号位, 正数大于负数
    * 同为正数, 数越大, 值越大
    * 同为负数, 数越大, 值越小
* 正数+正数: 需要使用加法器处理, 像列竖式一样, 高位直接舍弃
* 正数-正数: 需要使用减法器处理

### 反码
* 计算:
    * 正数的反码和原码相同
    * 负数的反码在原码的基础上, 把除符号位外的所有位取反
* 定义:
    * 最高位取负, 值为 2^(w-1) - 1, 其他位取正, 即:
    * 0000 == -0*(2^3-1) + 0*2^2 + 0*2^1 + 0*2^0 = -0 + 0 + 0 + 0 = +0
    * 1111 == -1*(2^3-1) + 1*2^2 + 1*2^1 + 1*2^0 = -7 + 4 + 2 + 1 = -0
    * 0111 == -0*(2^3-1) + 1*2^2 + 1*2^1 + 1*2^0 = -0 + 4 + 2 + 1 = +7(最大)
    * 1000 == -1*(2^3-1) + 0*2^2 + 0*2^1 + 0*2^0 = -7 + 0 + 0 + 0 = -7(最小)
* 比较大小(比使用原码好一点, 同号的比较大小可以统一)
    * 先比较符号位, 正数大于负数
    * 同为正数, 数越大, 值越大
    * 同为负数, 数越大, 值越小
* 正数+正数: 无意义
* 正数-正数: 无意义

### 补码
* 计算
    * 正数的补码和原码相同
    * 负数的补码在反码的基础上, 在最后一位加一
* 定义:
    * 最高位取负, 其他位取正
    * 0000 == -0*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = -0 + 0 + 0 + 0 = +0
    * 0111 == -0*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = -0 + 4 + 2 + 1 = +7(最大)
    * 1000 == -1*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = -8 + 0 + 0 + 0 = -8(最小)
* 比较大小(比使用原码好一点, 同号的比较大小可以统一)
    * 先比较符号位, 正数大于负数
    * 同为正数, 位数越大, 值越大
    * 同为负数, 位数越大, 值越大
* 正数+正数: 使用加法器处理
* 正数-正数: 可以转化为 正数 + 负数, 然后使用加法器处理(补码存在的主要目的)
* 补码变符号
    * 正数(+1) => 负数(-1) == 正数的补码(0001)各位取反(1110), 然后加一(1111)
    * 负数(-1) => 正数(+1) == 负数的补码(1111)各位取反(0000), 然后加一(0001)
* 加法器: 像列竖式一样, 从低到高, 一位一位相加, 该进就进, 超过最高位直接舍弃

### 移码
* 在原码的基础上加一个数字, 使得所有的数字都是非负数
* 比较大小: 直接比较即可
* 加法: 无意义
* 减法: 无意义

### 字节序(单元大小是多字节的数据, 高字节在前还是在后)
* 网络字节序(大端)
* 内存中存储(大小端由 CPU 决定, 一般使用小端存储)(主机字节序)
* 文件内存储二进制(同内存中存储)(二进制文件)
* 文件中存储字符(由 BOM 决定)(文本文件)

### 大小端
#### 大端存储(高字节存储在内存的低字节)
* 方便判断正负
* 看起来直观, 手写的计算机存储和真实的存储一致

#### 小端存储(高字节存储在内存的高字节)
* 方便类型转换, 比如 int => short

#### 涉及的 C++ 类型
* 整形: short, int, long, long long
* 浮点型: float, double, long double
* 字符类: `wchar_t`, `char16_t`, `char32_t`

#### 判断
使用共同体或类似的方法

测试: [01.cc](./01.cc)

### BOM
* UTF-8 : 不需要 BOM (使用 vim 的 set nobomb 可以去掉 BOM)
* UTF-16: 由 BOM 指定
* UTF-32: 由 BOM 指定
* GBK: 不需要 BOM

## 无符号的整数的存储(内存以及二进制文件)
* 使用原码表示
* 溢出时舍弃高位
* 最小数: 0000(0*2^3+0*2^2+0*2^1+0*2^0 == 0)
* 最大数: 1111(1*2^3+1*2^2+1*2^1+1*2^0 == 15)
* unsigned char, unsigned short, usigned long, unsigned long long
* 除 unsigned char 外, 有大小端之分
* 无符号的整数 除以 无符号的整数 结果还是 无符号的整数, 小数部分直接舍弃

## 有符号的整数的存储(内存以及二进制文件)
* 使用补码表示(方便处理减法以及负数)
* 溢出时未定义
* 最小数: 1000(-1*2^3+0*2^2+0*2^1+0*2^0 == -8)
* 最大数: 0111(+0*2^3+1*2^2+1*2^1+1*2^0 == +7)
* signed char, short, long, long long
* 除 signed char 外, 有大小端之分
* 有符号的整数 除以 有符号的整数
    * 商的符号由除数和被除数决定, 取余的符号只和被除数有关(C++11)
    * 小数部分直接舍弃

测试: [02.cc](./02.cc)

## 浮点数的存储(内存以及二进制文件)
* 使用 double, 探索浮点数的存储以及精度的损失
* 区分大小端
* 格式: 1-符号位 11-阶码 52-尾码

### 浮点数的类型
* 正负  零: 阶码都为 0, 尾码  都为 0
* 非规约数: 阶码都为 0, 尾码不都为 0, 阶码的偏移量为 1022, 尾码整数部分为 0 (特别小的数字)
* 正负无穷: 阶码都为 1, 尾码  都为 0
* 非数字: 阶码都为 1, 尾码不都为 0
* 规约数: 阶码不都为 0, 也不都为 1, 阶码的偏移量为 1023, 尾码整数部分为 1
* 查看浮点数类型: pclassify(...)

### 浮点数的舍入模式
* 范围:
    * 浮点数存储(二进制)
    * 保留小数位数(十进制)
    * 如果不能精确处理, 是舍弃还是进一
* 向下舍入:
    * 正数: 舍弃
    * 负数: 进一
    * std::floor
* 向上舍入:
    * 正数: 进一
    * 负数: 舍弃
    * std::ceil
* 向零舍入:
    * 正数: 舍弃
    * 负数: 舍弃
    * std::trunc
    * 浮点数-->整数
* 四舍五入:
    * 只用于保留小数位数
    * 剩余部分第一位小于 5: 舍弃
    * 剩余部分第一位大于等于 5: 进一
    * std::round
* 最近舍入:
    * 四舍六入五取偶
    * 保留小数
        * 剩余部分第一位小于 5: 舍弃
        * 剩余部分第一位大于 5: 进一
        * 剩余部分第一位 5 后  存在非 0 位: 进一
        * 剩余部分第一位 5 后不存在非 0 位: 进一
            * 精确存储的的最后一位为奇数: 进一
            * 精确存储的的最后一位为偶数: 舍弃
    * 存储
        * 剩余部分第一位为 0: 舍弃
        * 剩余部分第一位为 1 且后  存在 非 0 位: 进一
        * 剩余部分第一位为 1 且后不存在 非 0 位
            * 精确存储的的最后一位为 1: 进一
            * 精确存储的的最后一位为 0: 舍弃
    * 默认是最近舍入
* 由舍入模式决定:
    * std::rint
    * std::nearbyint
* 查看舍入模式: fegetround()
* 设置舍入模式: fesetround(...)

#### 测试文件
* 测试保留小数时的四舍六入五取偶: [03.cc](./03.cc)
* 测试存储小数时的四舍六入五取偶: [04.cc](./04.cc)

### 浮点数异常(这个比较乱, 一般不重要)
* 范围:
    * 四则运算
    * 调用函数
    * 参数不合法 或者 结果不准确的问题
* 类型:
    * 除以 0
    * 结果不准确
    * 参数非法
    * 上溢
    * 下溢
* 清空浮点数异常: feclearexcept(...)
* 测试浮点数异常: fetestexcept(...)
* 可能会引发浮点数异常的场景:
    * 浮点数的四则运算
    * 绝大部分函数
* 不会引发浮点数异常的场景:
    * isless 只对 signaling NaN 抛出异常
    * nearbyint 系列

测试: [05.cc](./05.cc)

### 浮点数最多可以表示的小数点后的位数
* 最小非规约正数的最后一位非 0 位
* 1074 位

测试: [06.cc](./06.cc)

### 阶码为什么用移码? 不用补码, 反码, 原码
* 方便比较大小
    * 符号位特殊
    * 其他位直接比较即可
* 使用其他的还需要判断阶码的符号位

### 相邻可表示的浮点数的差值是不是一定的?
* 不是
* 离零越近, 差值越小
* 非规约数:
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 最大非规约正数 --> 最小规约正数
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 阶码相同时
    * 差值: 2 的 (阶码-1023-52) 次
* 阶码相邻时
    * 差值: 2 的 (小的阶码-1023-52) 次

### 非规约数的偏移量为什么是 1022, 不是 1023?, 非规约数的整数位为什么是 0, 不是 1?
* 设 a 为最大正非规约数的上一可表示数: 0 00000000000 (0)1111111111111111111111111111111111111111111111111110
* 设 b 为最大正非规约数              : 0 00000000000 (0)1111111111111111111111111111111111111111111111111111
* 设 c 为最小正规约数                : 0 00000000001 (1)0000000000000000000000000000000000000000000000000000
* 设 d 为最小正规约数的下一可表示数  : 0 00000000001 (1)0000000000000000000000000000000000000000000000000001
* 如果非规约数的偏移量是 1022, 非规约数的整数位是 0
    * a 为: -1022次 - -1074次 - -1074次 (-1022 - 52)
    * b 为: -1022次 - -1074次
    * c 为: -1022次
    * d 为: -1022次 + -1074次
    * b - a: -1074次
    * c - b: -1074次
    * d - c: -1074次
* 如果非规约数的偏移量是 1023, 非规约数的整数位是 0 (非规约数 => 规约数, 变化差值不太连续)
    * a 为: -1023次 - -1075次 - -1075次 (-1023 - 52)
    * b 为: -1023次 - -1075次
    * c 为: -1022次 == -1023次 + -1023次
    * d 为: -1022次 + -1074次
    * b - a: -1075次
    * c - b: -1075次 + -1023次
    * d - c: -1074次
* 如果非规约数的偏移量是 1022, 非规约数的整数位是 1(最大非规约数 大于 最小规约数, 不行)
    * a 为: -1022次 + -1022次 - -1074次 - -1074次 (-1022 - 52)
    * b 为: -1022次 + -1022次 - -1074次
    * c 为: -1022次
    * d 为: -1022次 + -1074次
    * b - a: -1074次
    * c - b: -1074次 - -1022次 (小于 0)
    * d - c: -1074次
* 如果非规约数的偏移量是 1023, 非规约数的整数位是 1(相比较, 第一种能表达更贴近 0 的数)
    * a 为: -1023次 + -1023次 - -1075次 - -1075次 (-1023 - 52)
    * b 为: -1023次 + -1023次 - -1075次
    * c 为: -1022次 == -1023次 + -1023次
    * d 为: -1022次 + -1074次
    * b - a: -1075次
    * c - b: -1075次
    * d - c: -1074次

测试: [07.cc](./07.cc)

### 规约数的隐藏位为什么是1?
为了节省空间

### 浮点数精度损失
* 范围
    * 浮点数存储
    * 浮点数取回
    * 浮点数计算
* 小于最小非规约正数的正数将当作 0
* 大于最大规约正数的数字将当作正无穷
* 以下仅讨论规约数和非规约数
* 浮点数字符串(a) --> 浮点数二进制(b)
    * 可能无法精确转换(0.1)
* 浮点数二进制(b) --> 浮点数科学计数(c)
    * 无精度损失
* 浮点数科学计数(c) --> 调节幂次(d)
    * 如果, 幂次小于 -1022
        * 将幂次改为 -1022
        * 同时调整小数部分
    * 无精度损失
* 调节幂次(d) --> 存储-52位(e)
    * 整数部分为 1, 表示规约数
    * 整数部分为 0, 表示非规约数
    * 只存储小数部分
    * 前 51 位精确存储
    * 最后一位四舍六入五取偶
    * 注意: 进一的时候可能引发前 51 位变化
* 存储-52位(e) --> 浮点数二进制(f)
    * 无精度损失
* 浮点数二进制(f) --> 浮点数十进制(g)
    * 无精度损失
* 浮点数十进制(g) --> 保留小数位数(h)
    * 默认: 四舍六入五取偶
* 一个精确的浮点数表示的上下限
    * 如果最后一位是 0, 则范围是 [下限, 上限]
    * 如果最后一位是 1, 则范围是 (下限, 上限)

测试: [08.cc](./08.cc)

### 15 位精度是什么意思?
* 并不是说: 所有数字的前15位可以精确表示(0.1 不能精确表示)
* 而是说计算机能保证的能区分的精度是 15 位, 在指数相同的情况下, 存储的不同数的前 15 位有效数字是不同的
* 超过 15 位也可能能表示

#### 理解
* 符号位, 阶码固定的情况下, 相邻的可表示数的差值是固定的, 可表示数的状态也是固定的
* 52 位二进制能表示 4503599627370496 种状态
* 53 位二进制能表示 9007199254740992 种状态
* 即 能够准确表示十五位状态
* 即 能够保证的精度是十五位数
* 还是不太清楚, 先放下吧,...

测试: [09.cc](./09.cc)

## 字符存储(内存 二进制文件 文本文件)(建议只使用不带bom的utf-8)
* 编码: 字符 -> 计算机存储
* 解码: 计算机存储 -> 字符
* 字符集:
    * ASCII (和编码规则一一对应)
    * GB2312 => GBK(cp936) => GB18030 (和编码规则一一对应)
    * BIG5
    * Unicode
    * Latin1(ISO-8859-1) 单字节使用完整的八位字节, 所以可以将其他编码当作 Latin1 来传输不会丢失数据
* 编码规则:
   * UTF-8
        * 文本文件: 不需要 BOM, 存在也成(FE FF => EF BB BF)(建议不要)
        * 内存以及二进制文件: 不需要考虑字节序
   * UTF-16
        * 文本文件: 需要 BOM(FE FF 或 FF FE)
        * 内存以及二进制文件: 和主机的字节序相同
   * UTF-32
        * 文本文件: 需要 BOM(00 00 FE FF 或 FF FE 00 00)
        * 内存以及二进制文件: 和主机的字节序相同
   * windows 的 记事本 的 ASCI   : 本地编码
   * windows 的 记事本 的 unicode: 带 BOM 的小端的 UTF-16
   * windows 的 记事本 的 utf-8  : 带 BOM 的 UTF-8
* 文件编码转换: iconv -f gbk -t utf-8 1.txt -o 1.txt
* 文件编码不一定能准确获取
* 在 C++ 中使用(建议只使用 UTF-8)
    * UTF-8 : char, string   ,  ".....", u8"....."
    * UTF-16: char, u16string, u"....."
    * UTF-32: char, u32string, U"....."
    * 字符串常量以 \u 开头的四个十六进制数表示 Unicode
    * 字符串常量以 \U 开头的八个十六进制数表示 Unicode

测试: [10.cc](./10.cc)

## 查看二进制(内存)
* 使用 gdb
* 在代码中直接读取内存中存储的值

## 查看二进制(文件)
* xxd
* hd
* hexdump
* od

